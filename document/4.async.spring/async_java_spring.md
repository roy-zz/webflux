### Spring WebFlux Series - 6

이번 장에서는 자바와 스프링의 비동기 개발 기술에 대해서 알아본다.
모든 코드는 [깃허브 (링크)](https://github.com/roy-zz/webflux)의 테스트 코드에 있으므로 필요하다면 참고하도록 한다.

---

### 개요

리액티브 프로그래밍을 Flux와 Mono를 사용하여 몇가지 API를 작성하는 것만으로 이해했다고 보기는 힘들다.
물론 보는 관점에 따라 다를 수는 있지만 핵심 기술을 이해해야 리액티브 프로그래밍을 제대로 이해하고 사용할 수 있다.
리액티브 프로그래밍을 옵저버 패턴을 사용하여 역할이 다른 관찰자와 관찰 대상자를 나누어 구현하는 구조만을 말하는 것이 아니라 비동기적인 동작 환경에서 어떠한 의미를 가지는지 살펴봐야 한다.

스프링이 10년 이상 유지한 MVC 방식에서 어떠한 문제를 해결하기 위해 Reactive 방식을 적용하기 시작하였는지에 대해서 알아봐야 한다.
자바의 경우 1.4에서 등장한 concurrent 패키지는 이후 계속 업데이트를 통해 발전하고 있다.
스프링으로 보면 출시된지 15년 정도된 2.0 버전에서 어떻게 비동기 방식을 스프링에 녹일 것인지에 대한 고찰이 있었으며 현재까지 지속적으로 발전되고 있다.
스프링은 자바의 비동기 기술과 비동기 관련 오픈소스 기술을 참고하여 스프링에 비동기 기술을 녹여왔다.
어떠한 방식으로 발전을 해왔고 자바 1.8에서의 커다란 변화와 Reactive를 도입하기까지의 중요한 일들에 대해서 살펴본다.

---

### 고전적인 방식의 비동기 프로그래밍

Java 1.5에 등장한 Future 인터페이스를 확인해본다.

Future란 비동기적인 작업의 결과를 나타내는 것이다. 
스레드 자기 자신이 아닌 새로운 스레드를 생성하여 새로운 작업을 수행한다는 의미이며 다른 스레드에 의해 완성된 결과를 가져오는 대표적인 인터페이스가 Future다.

ExecutorService를 사용하여 스레드 풀을 생성한다.
newCachedThreadPool은 스레드의 갯수 제한은 없으며 요청할 때마다 새로 만들고 요청을 처리하고 스레드를 풀에 반납한다. 새로운 요청이 들어왔을 때 스레드 풀의 스레드로 요청을 처리한다.







**참고한 강의:**

- https://www.youtube.com/watch?v=aSTuQiPB4Ns&ab_channel=TobyLee




