스케쥴러도 다양하고 스레드풀의 종류도 다양하므로 적절한 경우에 사용해야한다.
레이턴시를 낮추는 방법 또는 실행 속도를 빠르게 만드는 방법 등 여러가지 방법이 있따.
우선순위를 뒤로 미뤄서 최대한 천천히 처리하는 방법
논블로킹 IO를 사용하여 스레드를 빠르게 반환하여 효율적으로 사용하는 방법 등등 다양한 전략이 있다.

여러 종류의 Publisher가 복합적으로 구성되어 있을 때 특정 Publisher만 특정 스케쥴러를 사용하도록 만들 수도 있다.
이러한 방법을 전부 알아야 Reactive Programming의 고수가 될 수 있지만 분석하는 것도 쉽지가 않다.
범위가 넓어지고 커지면 전체를 보고 어떤 부분을 비동기로 처리해야 Latency가 높아질 수 있을지 분석할 수 있어야한다.

Reactor에는 따로 subscribeOn을 사용하지 않아도 별도의 스레드가 생성되어 요청을 처리할 수 있다.
일정 주기 간격으로 무한대로 데이터를 발생시키는 interval을 사용해보면 예상과 다르게 실행되지 않고 메인 스레드가 종료되는 것을 볼 수 있다.

StackOverflow와 같은 많은 사이트에서 이러한 문제를 해결하기위해 sleep을 사용하라는 글을 볼 수 있다.
하지만 지정한 sleep 시간이 지나면 우리의 예상과 다르게 메인 스레드가 종료되는 것을 볼 수 있다.

subscribe 내에서 로그를 생성하는 스레드를 보면 parallel-1이라는 스레드인 것을 확인할 수 있다. 어떠한 이유에서 메인 스레드가 종료되는지 원인을 찾아야한다.
main 스레드가 종료되니까 parallel-1이라는 스레드도 종료되는게 맞다고 생각할 수도 있지만 결과를 먼저 말하면 그렇지 않다.
아래의 예제를 한 번 살펴본다.
기존과 다르게 테스트 코드는 유저 스레드가 살아있어도 종료되어 테스트 코드를 위한 클래스 내부에 main 메서드를 생성하고 테스트를 진행하였다.

유저가 만든 스레드인 유저 스레드는 메인 스레드가 종료되어도 종료되지 않는다.
강제로 종료, 인터럽트, 작업이 종료되기 전에는 종료되지 않는다.

스레드의 종류에는 유저 스레드와 데몬 스레드가 있는데 JVM에 유저 스레드가 하나도 남아있지 않고 데몬 스레드만 남아있다면 강제로 종료된다.

Executors.newSingleThreadExecutor()으로 생성하는 스레드는 우리가 직접 생성한 유저 스레드이다.
반면 interval에서 생성된 스레드는 데몬 스레드로서 테스트 코드에서 남아있는 유저 스레드가 없기 때문에 강제로 종료가 된 것이다.

interval의 경우 수많은 유저 스레드와 함께 생성되어 사용자가 종료되기 전까지 죽지 않고 살아있다.
만약 interval에서 사용하는 스레드가 유저 스레드이며 개발자가 종료시점을 지정하지 않는다면 애플리케이션 종료시점에 문제가 발생할 수도 있다는 판단에 스프링에서 데몬 스레드로 만들었을 것으로 추측된다.

take의 경우 데이터가 몇 개가 발생하던 자신이 정해놓은 수치만큼만 잘라서 받을 수 있다.
take는 DB에서 limit을 사용하여 일부 데이터만 추출하는 방식과 같이 상위 몇개의 데이터만 추출할 때 편리하다.

마지막으로 take를 직접 구현하는 방법에 대해서 알아본다.
